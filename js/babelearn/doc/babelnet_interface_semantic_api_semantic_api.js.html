<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: babelnet_interface/semantic_api/semantic_api.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: babelnet_interface/semantic_api/semantic_api.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*jshint esversion: 8 */

import { BabelProxy } from '../babelproxy/babelproxy.js'

/**
 * Convenience class to represent a custom exception.
 */
export class NotInitializedError extends Error{}

/**
 * Represents the semantic description of a certain sentence in a certain language. It uses a {@link BabelProxy} instance
 * in order to disambiguate the sense of the words used in the sentence using the Babelfy API.
 * Since full initialization requires Internet access, the bulding process of an instance of this class is split in two parts,
 * to allow to defer the time-consuming Internet communication to when it's more appropriate for the API user. When the object is built
 * the information necessary to the disambiguation is stored, but for the disambiguation to actually happen it's necessary to call the initialize()
 * method on the instance, so it must be called before using any other method or accessing any property of the instance.
 */
export class SemanticSentenceDescription {
    /**
     * Stores the information necessary for the disambiguation process to succeed.
     *
     * @param {string} sentence The sentence to analyze.
     * @param {string} language The language the given sentence is expressed into. Use two letters abbreviation, e.g. 'EN' for English.
     * @throws {TypeError} if sentence or language are not specified.
     */
    constructor(sentence, language){
        if(sentence == null || language == null){
            throw new TypeError('Sentence and her language must be both specified.');
        }

        this.sentence = sentence;
        this.sentenceLang = language;

        /** @private */
        const key = 'a35c7c44-37db-42c6-90c1-b8f7dbc78cfb';
        this.proxy_ = new BabelProxy(key);
        console.log("Your key is: ", this.proxy_.apiKey); // DEBUG

        this.isInitialized = false;
        this.disambiguatedWords = null; // Google style conventions require to set all of the fields in the constructor
    }

    /**
     * Performs the actual disambiguation, and stores the result as a mapping {word: synsetID} for each word in the
     * sentence associated to this object whose sense the Babelfy API was able to disambiguate.
     */
    async initialize(){
        this.disambiguatedWords = await this.proxy_.getBabelfySynsets(this.sentence, this.sentenceLang);
        this.isInitialized = true;
    }

    /**
     * Checks if the instance has been initialized before using any other method on her.
     *
     * @private
     * @throws {NotInitializedError} if initialize() has not been called on this instance.
     */
    initializationErrorChecking_(){
        if(!this.isInitialized){
            throw new NotInitializedError('This instance of SemanticSentenceDescription is not initialized. Please call initialize() on her.')
        }
    }

    /**
     * Checks if a given word has been used in this sentence (with the sense associated to the {@link SemanticWordDescription} which
     * encapsulates the word).
     *
     * @param {SemanticWordDescription} word The semantic description of the word to check for usage.
     * @throws {NotInitializedError} if initialize() has not been called on this instance.
     */
    checkForUsage(semanticWordDescription){
        /**
         * Checks if the synset ID associated to the given SemanticWordDescription is the same as one of the synset IDs
         * disambiguated by Babelfy for this sentence.
         */

        this.initializationErrorChecking_();

        var synsetIDs = [];
        this.disambiguatedWords.forEach((element) => {
            synsetIDs.push(element['synsetID']);
        });

        return synsetIDs.includes(semanticWordDescription.synsetID_);

    }

    /**
     * Returns a {@link SemanticWordDescription} object encapsulating the meaning found by Babelfy for the given
     * word of the sentence associated to this object.
     * The returned SemanticWordDescription object must be initialized before being used.
     * NOTE: for this method to succeed, the exact given word must have been used in the sentence associated to this object.
     *
     * @param {string} word The word of the sentence associated to this object whose meaning, if found, will be encapsulated in the returned object.
     * @param {string[]} targetLanguages The languages to associate to the returned {@link SemanticWordDescription}. Use two letters abbreviation, e.g. 'EN' for English.
     * @returns {SemanticWordDescription} A {@link SemanticWordDescription} encapsulating the given word and her meaning in the sentence associated to this {@link SemanticSentenceDescription}.
     *     Returns null if the given word has not been used in this sentence.
     * @throws {NotInitializedError} if initialize() has not been called on this instance.
     */
    getSemanticWordDescription(word, targetLanguages){
        /**
         * This method is useful because after obtaining the semantic description of a word of the sentence the
         * checkForEquality can be invoked on her passing the SemanticWordDescription of another word, allowing to check
         * if a (exact) word has been used in the sentence with the same meaning as another word.
         */
        this.initializationErrorChecking_();

        // Get all the available words (can't use Object.keys() because it would return array indices)
        var words = [];
        this.disambiguatedWords.forEach((element) => {
            words.push(element['word']);
        });

        // Check if the required word is available
        if(word == null || !words.includes(word)){
            return null;
        }

        // Loop over the available words (due to the previous check, the required word is surely available)
        for(var i = 0; i &lt; words.length; i++){
            if(words[i] == word){
                // When you find the required one, build a SemanticWordDescription object through her synsetID
                return new SemanticWordDescription(null, null, targetLanguages, this.disambiguatedWords[i]['synsetID']);
            }
        }
    }
}

/**
 * Represents the semantic description of a certain word.
 * When the constructor is called, the information necessary to build the description is stored in the instance, but
 * since actually building the description requires Internet communication, this action is deferred to when the initialize()
 * method is called, in order to allow the API user to choose when this communication must happen. This implies that it's
 * mandatory to call the initialize() method before calling any other method or accessing any property of the instance.
 */
export class SemanticWordDescription {
    /**
     * Default parameters here are only for documentation purposes.
     *
     * @param {string} word The word whose semantic description will be built. Can be omitted if the synsetID is provided.
     * @param {string} language The language the given word is expressed into. Use two letters abbreviation, e.g. 'EN' for English. Can be omitted if the synsetID is provided.
     * @param {string[]} targetLangs The languages in which language-dependent elements (lemma, examples, meaning) of this instance will be available. Use two letters abbreviation, e.g. 'EN' for English.
     * @param {string} synsetID The synsetID upon which the semantic word description encapsulated by this object will be built.
     *     Can be omitted if word and language are provided.
     * @throws {TypeError} if neither the synsetID nor word and language have been specified.
     * @throws {RangeError} if target languages have not been specified, they are too many or they have not been provided as an array
     */
    constructor(word=null, language=null, targetLangs=['EN'], synsetID=null){
        // synsetID or word AND language must be provided
        if(synsetID == null &amp;&amp; (word == null || language == null)){
            throw new TypeError('The synset ID or the desired word and her language must be specified.');
        }

        if (targetLangs == null || targetLangs.length > 4 || targetLangs.length &lt; 1 || !Array.isArray(targetLangs)){
            throw new RangeError('At least 1 and at most 4 target languages must be specified by passing an array of strings.');
        }

        /** @private */
        const key = 'a35c7c44-37db-42c6-90c1-b8f7dbc78cfb';
        this.proxy_ = new BabelProxy(key);


        /** @private */
        this.synsetID_ = synsetID;

        /** @private */
        this.lemma_ = word;

        /**
         * This value allows to select different meanings of the same word: it's used by the nextMeaning() method.
         * @private
         * */
        this.meaningPos_ = 0;

        /** @private */
        this.apiResponse_ = null; // Google style conventions require to set all of the fields in the constructor

        /** @private */
        this.maxMeaningPos_ = null;

        this.wordLang_ = language; // language 'word' is expressed into
        this.availableLangs = targetLangs;
        this.isInitialized = false;

        /**
         * Wheter on a call to initialize() a re-initialization must be forced (e.g. to change meaning).
         * @private
         */
        this.reinit_ = false;

        /**
         * List of image URLs from Google image search API
         * @private
         */
        this.googleImages_ = null;

        /**
         * Cache for synset IDS
         *
         * @private
         */
        this.synsetIDs_ = null;
    }

    /**
     * Searches for images associated to given word, on Google Image Search.
     * 
     * @param {string} word
     * @returns {string[]} A list of image URLs. Can be empty if no image is found.
     * @private
     */
    async getGoogleImages_(word){
        
        var getParams = new URLSearchParams();

        getParams.append('q', word);
        getParams.append('tbm', 'isch');
        getParams.append('ijn', 0);

        var googleImageSeachUrl = 'https://serpapi.com/search.json';
        var googleImages = [];

        try{
            await axios({
                headers: {"Access-Control-Allow-Origin": "*"},
                url: googleImageSeachUrl,
                method: 'get',
                responseType: 'json',
                params: getParams
            }).then((response) =>
                response.images_results.forEach((image) =>
                    googleImages.append(image.original)
                )
            );
        }catch(err){
            // An exception is already thrown by get, so don't throw anything else here, simply
            // stop execution flow
            console.log('Error during get from Google image search API: ', err);
            return;
        }

        return googleImages;
    }

    /**
     * Actually populates this object's member variables with the data received by the BabelNet API.
     *
     */
    async initialize(){
        /**
         * When a synsetID is given, the information regarding the lemma and her language is taken by the first sense available
         * in the response received by the BabelNet API. This flag is used to understand whether this must be done.
         */
        var isSynsetIdGiven = false;

        console.log('Initializing with ', this.meaningPos_, ' meaning pos and ', this.synsetID_, ' synsetID');

        // The synsetID, if specified, is the preferred method to build the instance
        if(this.synsetID_ == null){
            // it was not provided in the constructor
            this.synsetIDs_ = await this.proxy_.getSensesSynsets(this.lemma_, this.wordLang_); // VSCode suggests that await has no effect here, but evidences show that it has.
            // Reduce the number of synsets considered to the 50 most significant ones, in order to reduce the number of requests made to the API when it's necessary
            // to look for different meanings
            this.synsetIDs_ = this.synsetIDs_.slice(0, 50);
            console.log("numero di synset ID: ", this.synsetIDs_.length); // DEBUG
            console.log("wordLang: ",this.wordLang_); // DEBUG
            console.log("lemma: ", this.lemma_); // DEBUG
            this.maxMeaningPos_ = this.synsetIDs_.length; // maximum number of different meanings available
            this.synsetID_ = this.synsetIDs_[this.meaningPos_];
        }
        else{
            isSynsetIdGiven = true;
        }

        if(this.reinit_){
            // change synset ID
            this.synsetID_ = this.synsetIDs_[this.meaningPos_];
        }

        await this.proxy_.getSynsetInfo(this.synsetID_, this.availableLangs).then((res)=>{
          this.apiResponse_ = res;
        });

        if(isSynsetIdGiven &amp;&amp; !this.reinit_){
            // Init wordLang and lemma to the values of the first sense in the response
            this.wordLang_ = this.apiResponse_["senses"][0]["properties"]["language"];
            this.lemma_ = this.apiResponse_["senses"][0]["properties"]["simpleLemma"];
        }

        // at this point, lemma is surely initialized
        //this.googleImages_ = await this.getGoogleImages_(this.lemma_).then((res) => {});

        this.isInitialized = true;
        this.reinit_ = false;
    }

    /**
     * Checks if there exists another synset ID associated to this word.
     * 
     * @returns {boolean} True if another meaning is available, false otherwise.
     */
    hasAnotherMeaning(){
        this.initializationErrorChecking_();

        return this.maxMeaningPos_ - 1 > this.meaningPos_;
    }

    /**
     * Loads the next meaning of the word associated to this object (the next meaning is the one associated with the next synset ID).
     *
     * @throws {RangeError} if no new meaning is available for the word encapsulated by this object.
     */
    async nextMeaning(){
        this.initializationErrorChecking_();

        if(this.hasAnotherMeaning()){
            this.meaningPos_ += 1;
            this.reinit_ = true;
            await this.initialize();
        }
        else{
            throw new RangeError('No new meaning is available for this word.');
        }
    }

    /**
     * Checks if the instance has been initialized before using any other method on her.
     *
     * @private
     * @throws {NotInitializedError} if initialize() has not been called on this instance.
     */
    initializationErrorChecking_(){
        if(!this.isInitialized){
            throw new NotInitializedError('This instance of SemanticWordDescription is not initialized. Please call initialize() on her.')
        }
    }

    /**
     * Convenience method used by the methods which receive a desired language as a parameter to check if that
     * language is available for this semantic word description.
     *
     * @param {string} lang Desired language. Use two letters abbreviation, e.g. 'EN' for English.
     * @private
     * @throws {TypeError} if the required language is not available.
     */
    desiredLangValidation_(lang){
        if(!this.availableLangs.includes(lang)){
            console.log(lang," is not available");
            throw new TypeError('The requested language is not available.');
        }
    }

    /**
     * Retrieves the first lemma in the required language associated to this {@link SemanticWordDescription}.
     *
     * @param {string} targetLang Language of the retrieved lemma. Must be one of the languages specified when this object was built. Use two letters abbreviation, e.g. 'EN' for English.
     * @returns {string} The first lemma in the required language associated to this {@link SemanticWordDescription}.
     * @throws {TypeError} if the lemma is not available in the required language.
     */
    getLemma(targetLang){
      this.initializationErrorChecking_();
        if(targetLang == null || (this.wordLang_ != targetLang &amp;&amp; !this.availableLangs.includes(targetLang))){
            throw new TypeError('Lemma not available in the required language.');
        }

        var senses = this.apiResponse_["senses"];
        for(var i = 0; i &lt; senses.length; i++){
            if(senses[i]['properties']['language'] == targetLang){
                return senses[i]['properties']['simpleLemma'];
            }
        }
    }

    /**
     * Retrieves the meaning of the word associated to this SemanticWordDescription, in the required language.
     *
     * @param {string} lang Language of the retrieved meaning. Must be one of the languages specified when this object was built. Use two letters abbreviation, e.g. 'EN' for English.
     * @returns {string} The meaning of the word associated to this SemanticWordDescription, in the required language.
     *     If no valid meaning is available, returns null.
     * @throws {NotInitializedError} if initialize() has not been called on this instance.
     * @throws {TypeError} if the required language is not available.
     */
    getMeaning(lang){
        this.initializationErrorChecking_();

        this.desiredLangValidation_(lang);

        // forEach does not work properly here
        var glosses = this.apiResponse_.glosses;
        for(var i = 0; i &lt; glosses.length; i++){
            if(glosses[i]['language'] == lang){
                return glosses[i]['gloss'];
            }
        }

        // It's not sure that a synset will always be associated to a gloss (see notes)
        return null;
    }

    /**
     * Retrieves usage examples for the word associated to this SemanticWordDescription, in the required language.
     *
     * @param {string} lang The language the examples will be expressed into. Must be one of the languages specified when this object was built. Use two letters abbreviation, e.g. 'EN' for English.
     * @returns {string[]} All the examples available in the required language. Can be an empty list if no example is found.
     * @throws {NotInitializedError} if initialize() has not been called on this instance.
     * @throws {TypeError} if the required language is not available.
     */
    getExamples(lang){
        this.initializationErrorChecking_();
        this.desiredLangValidation_(lang);

        var examplesList = [];

        this.apiResponse_.examples.forEach((example) => {
            examplesList.push(example['example']);
        });

        return examplesList;
    }

    /**
     * Retrieves images associated to the word linked to this SemanticWordDescription.
     *
     * @returns {string[]} An array containing the URLs of the images. Returned array could be empty if no image is found.
     * @throws {NotInitializedError} if initialize() has not been called on this instance.
     */
    getImages(){
        this.initializationErrorChecking_();

        var imageURLs = [];

        this.apiResponse_.images.forEach((image) => {
            imageURLs.push(image['url']);
        });

        return imageURLs;
    }

    /**
     * Retrieves images associated to the word linked to this SemanticWordDescription.
     * 
     * @returns {string[]} An array containing the URLs of the images. Returned array could be empty if no image is found.
     * @throws {NotInitializedError} if initialize() has not been called on this instance.
     */
    getGoogleImages(){
        this.initializationErrorChecking_();

        return this.googleImages_;
    }

    /**
     * Checks if a word in a given language is compatible with the word associated to this semantic word description.
     * The term "compatible" is used instead of "equal" because the comparison is based on the existence of a synsetID
     * associated to the given word which is equal to the synsetID associated to this object, but, if for example the
     * given word is extracted from a sentence without prior disambiguation, that word could have been used in that
     * sentence with a meaning different from the meaning of the word associated to this object.
     *
     * @param {string} word
     * @param {string} lang Can be any language (but it must be supported by the BabelNet API). Use two letters abbreviation, e.g. 'EN' for English.
     * @returns {boolean} True if the words are compatible.
     * @throws {NotInitializedError} if initialize() has not been called on this instance.
     */
    async checkForCompatibility(word, lang){
        this.initializationErrorChecking_();

        // Get a list of the synsetIDs associated to the given word
        var inSynsets = await this.proxy_.getBabelnetSynsets(word, lang);

        // Check if one of them is equal to the synsetID associated to this object
        for(var i = 0; i &lt; inSynsets.length; i++){
            if(inSynsets[i] == this.synsetID_){
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if two words are equal (same lemma and meaning).
     *
     * @param {SemanticWordDescription} semanticWordDescription The word to compare with the one associated to this object.
     * @returns {boolean} True if the words associated to this object and the given one are equal (same lemma and meaning).
     * @throws {NotInitializedError} if initialize() has not been called on this instance.
     */
    checkForEquality(semanticWordDescription){
        // Check if the synsetIDs are equal
        this.initializationErrorChecking_();
        
        return semanticWordDescription.synsetID_ == this.synsetID_;
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BabelProxy.html">BabelProxy</a></li><li><a href="Challenge.html">Challenge</a></li><li><a href="ChallengeBuildFailedError.html">ChallengeBuildFailedError</a></li><li><a href="ChallengeFactory.html">ChallengeFactory</a></li><li><a href="ExampleFromMeaningChallenge.html">ExampleFromMeaningChallenge</a></li><li><a href="FourImagesOneWordChallenge.html">FourImagesOneWordChallenge</a></li><li><a href="Game.html">Game</a></li><li><a href="MeaningFromExampleChallenge.html">MeaningFromExampleChallenge</a></li><li><a href="NotInitializedError.html">NotInitializedError</a></li><li><a href="SemanticSentenceDescription.html">SemanticSentenceDescription</a></li><li><a href="SemanticWordDescription.html">SemanticWordDescription</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CHALLENGE_DIFFICULTY">CHALLENGE_DIFFICULTY</a></li><li><a href="global.html#CHALLENGE_TYPE">CHALLENGE_TYPE</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Mon Jan 18 2021 20:51:41 GMT+0100 (Ora standard dell’Europa centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
